"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const messaging_api_telegram_1 = require("messaging-api-telegram");
const TelegramContext_1 = __importDefault(require("../context/TelegramContext"));
const TelegramEvent_1 = __importDefault(require("../context/TelegramEvent"));
class TelegramConnector {
    constructor(options) {
        if ('client' in options) {
            this._client = options.client;
        }
        else {
            const { accessToken, origin } = options;
            this._client = messaging_api_telegram_1.TelegramClient.connect({
                accessToken,
                origin,
            });
        }
    }
    _getRawEventFromRequest(body) {
        return body;
    }
    get platform() {
        return 'telegram';
    }
    get client() {
        return this._client;
    }
    getUniqueSessionKey(body) {
        if (body.message) {
            return `${body.message.chat.id}`;
        }
        if (body.edited_message) {
            return `${body.edited_message.chat.id}`;
        }
        if (body.channel_post) {
            return `${body.channel_post.chat.id}`;
        }
        if (body.edited_channel_post) {
            return `${body.edited_channel_post.chat.id}`;
        }
        if (body.inline_query) {
            return `${body.inline_query.from.id}`;
        }
        if (body.chosen_inline_result) {
            return `${body.chosen_inline_result.from.id}`;
        }
        if (body.callback_query) {
            if (body.callback_query.message) {
                return `${body.callback_query.message.chat.id}`;
            }
            return `${body.callback_query.from.id}`;
        }
        if (body.shipping_query) {
            return `${body.shipping_query.from.id}`;
        }
        if (body.pre_checkout_query) {
            return `${body.pre_checkout_query.from.id}`;
        }
        return '';
    }
    updateSession(session, body) {
        return __awaiter(this, void 0, void 0, function* () {
            if (body.channel_post) {
                session.channel = body.channel_post.chat;
            }
            else if (body.edited_channel_post) {
                session.channel = body.edited_channel_post.chat;
            }
            if (session.channel) {
                session.channel._updatedAt = new Date().toISOString();
                Object.freeze(session.channel);
            }
            Object.defineProperty(session, 'channel', {
                configurable: false,
                enumerable: true,
                writable: false,
                value: session.channel,
            });
            if (body.message && body.message.chat.type === 'group') {
                session.group = body.message.chat;
            }
            else if (body.edited_message &&
                body.edited_message.chat.type === 'group') {
                session.group = body.edited_message.chat;
            }
            else if (body.callback_query &&
                body.callback_query.message &&
                body.callback_query.message.chat.type === 'group') {
                session.group = body.callback_query.message.chat;
            }
            if (session.group) {
                session.group._updatedAt = new Date().toISOString();
                Object.freeze(session.group);
            }
            Object.defineProperty(session, 'group', {
                configurable: false,
                enumerable: true,
                writable: false,
                value: session.group,
            });
            if (body.message) {
                session.user = body.message.from;
            }
            else if (body.edited_message) {
                session.user = body.edited_message.from;
            }
            else if (body.inline_query) {
                session.user = body.inline_query.from;
            }
            else if (body.chosen_inline_result) {
                session.user = body.chosen_inline_result.from;
            }
            else if (body.callback_query) {
                session.user = body.callback_query.from;
            }
            else if (body.shipping_query) {
                session.user = body.shipping_query.from;
            }
            else if (body.pre_checkout_query) {
                session.user = body.pre_checkout_query.from;
            }
            if (session.user) {
                session.user._updatedAt = new Date().toISOString();
                Object.freeze(session.user);
            }
            Object.defineProperty(session, 'user', {
                configurable: false,
                enumerable: true,
                writable: false,
                value: session.user,
            });
        });
    }
    mapRequestToEvents(body) {
        const rawEvent = this._getRawEventFromRequest(body);
        return [new TelegramEvent_1.default(rawEvent)];
    }
    createContext(params) {
        return new TelegramContext_1.default(Object.assign(Object.assign({}, params), { client: this._client }));
    }
    preprocess() {
        return {
            shouldNext: true,
        };
    }
}
exports.default = TelegramConnector;
//# sourceMappingURL=TelegramConnector.js.map