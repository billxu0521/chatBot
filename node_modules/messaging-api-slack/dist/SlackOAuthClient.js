"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const querystring_1 = __importDefault(require("querystring"));
const axios_error_1 = __importDefault(require("axios-error"));
const axios_1 = __importDefault(require("axios"));
const lodash_omit_1 = __importDefault(require("lodash.omit"));
const url_join_1 = __importDefault(require("url-join"));
const messaging_api_common_1 = require("messaging-api-common");
class SlackOAuthClient {
    constructor(accessTokenOrConfig) {
        let origin;
        if (typeof accessTokenOrConfig === 'string') {
            // Bot User OAuth Access Token
            this._token = accessTokenOrConfig;
            this._onRequest = messaging_api_common_1.onRequest;
        }
        else {
            const config = accessTokenOrConfig;
            this._token = config.accessToken;
            this._onRequest = config.onRequest || messaging_api_common_1.onRequest;
            origin = config.origin;
        }
        // Web API
        // https://api.slack.com/web
        this._axios = axios_1.default.create({
            baseURL: `${origin || 'https://slack.com'}/api/`,
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
        });
        this._axios.interceptors.request.use(config => {
            this._onRequest({
                method: config.method,
                url: url_join_1.default(config.baseURL || '', config.url || '/'),
                headers: Object.assign(Object.assign(Object.assign({}, config.headers.common), (config.method ? config.headers[config.method] : {})), lodash_omit_1.default(config.headers, [
                    'common',
                    'get',
                    'post',
                    'put',
                    'patch',
                    'delete',
                    'head',
                ])),
                body: config.data,
            });
            return config;
        });
    }
    static connect(accessTokenOrConfig) {
        return new SlackOAuthClient(accessTokenOrConfig);
    }
    get axios() {
        return this._axios;
    }
    get accessToken() {
        return this._token;
    }
    callMethod(method, _body = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const body = lodash_omit_1.default(_body, ['token', 'accessToken']);
                body.token = _body.accessToken || _body.token || this._token;
                const response = yield this._axios.post(method, querystring_1.default.stringify(body));
                const { data, config, request } = response;
                if (!data.ok) {
                    throw new axios_error_1.default(`Slack API - ${data.error}`, {
                        config,
                        request,
                        response,
                    });
                }
                return data;
            }
            catch (err) {
                throw new axios_error_1.default(err.message, err);
            }
        });
    }
    /**
     * Gets information about a public channel.
     *
     * https://api.slack.com/methods/channels.info
     */
    getChannelInfo(channelId, options = {}) {
        return this.callMethod('channels.info', Object.assign({ channel: channelId }, options)).then(data => data.channel);
    }
    /**
     * Lists all public channels in a Slack team.
     *
     * https://api.slack.com/methods/channels.list
     * FIXME: [breaking] support cursor, exclude_archived, exclude_members, limit
     */
    getChannelList(options = {}) {
        return this.callMethod('channels.list', options).then(data => data.channels);
    }
    /**
     * Retrieve information about a conversation.
     *
     * https://api.slack.com/methods/conversations.info
     */
    getConversationInfo(channelId, options = {}) {
        return this.callMethod('conversations.info', Object.assign({ channel: channelId }, options)).then(data => data.channel);
    }
    /**
     * Retrieve members of a conversation.
     *
     * https://api.slack.com/methods/conversations.members
     */
    getConversationMembers(channelId, options = {}) {
        return this.callMethod('conversations.members', Object.assign({ channel: channelId }, options)).then(data => ({
            members: data.members,
            next: data.response_metadata && data.response_metadata.next_cursor,
        }));
    }
    getAllConversationMembers(channelId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let allMembers = [];
            let continuationCursor;
            do {
                const { members, next, } = yield this.getConversationMembers(channelId, Object.assign({ cursor: continuationCursor }, options));
                allMembers = allMembers.concat(members);
                continuationCursor = next;
            } while (continuationCursor);
            return allMembers;
        });
    }
    /**
     * Lists all channels in a Slack team.
     *
     * https://api.slack.com/methods/conversations.list
     */
    getConversationList(options = {}) {
        return this.callMethod('conversations.list', options).then(data => ({
            channels: data.channels,
            next: data.response_metadata && data.response_metadata.next_cursor,
        }));
    }
    getAllConversationList(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let allChannels = [];
            let continuationCursor;
            do {
                const _options = continuationCursor
                    ? Object.assign({ cursor: continuationCursor }, options) : options;
                const { channels, next, } = yield this.getConversationList(_options);
                allChannels = allChannels.concat(channels);
                continuationCursor = next;
            } while (continuationCursor);
            return allChannels;
        });
    }
    /**
     * Sends a message to a channel.
     *
     * https://api.slack.com/methods/chat.postMessage
     */
    postMessage(channel, message, options = {}) {
        if (options.attachments && typeof options.attachments !== 'string') {
            // A JSON-based array of structured attachments, presented as a URL-encoded string.
            // eslint-disable-next-line no-param-reassign
            options.attachments = JSON.stringify(options.attachments);
        }
        else if (typeof message === 'object' &&
            message.attachments &&
            typeof message.attachments !== 'string') {
            // eslint-disable-next-line no-param-reassign
            message.attachments = JSON.stringify(message.attachments);
        }
        if (typeof message === 'string') {
            return this.callMethod('chat.postMessage', Object.assign({ channel, text: message }, options));
        }
        return this.callMethod('chat.postMessage', Object.assign(Object.assign({ channel }, message), options));
    }
    /**
     * Sends an ephemeral message to a user in a channel.
     *
     * https://api.slack.com/methods/chat.postMessage
     */
    postEphemeral(channel, user, message, options = {}) {
        if (options.attachments && typeof options.attachments !== 'string') {
            // A JSON-based array of structured attachments, presented as a URL-encoded string.
            // eslint-disable-next-line no-param-reassign
            options.attachments = JSON.stringify(options.attachments);
        }
        else if (typeof message === 'object' &&
            message.attachments &&
            typeof message.attachments !== 'string') {
            // eslint-disable-next-line no-param-reassign
            message.attachments = JSON.stringify(message.attachments);
        }
        if (typeof message === 'string') {
            return this.callMethod('chat.postEphemeral', Object.assign({ channel,
                user, text: message }, options));
        }
        return this.callMethod('chat.postEphemeral', Object.assign(Object.assign({ channel,
            user }, message), options));
    }
    /**
     * Gets information about a user.
     *
     * https://api.slack.com/methods/users.info
     */
    getUserInfo(userId, options = {}) {
        return this.callMethod('users.info', Object.assign({ user: userId }, options)).then(data => data.user);
    }
    /**
     * Lists all users in a Slack team.
     *
     * https://api.slack.com/methods/users.list
     * FIXME: [breaking] support include_locale, limit, presence
     */
    getUserList(cursorOrOptions) {
        if (typeof cursorOrOptions === 'string') {
            // cursorOrOptions is cursor string
            return this.callMethod('users.list', { cursor: cursorOrOptions }).then(data => ({
                members: data.members,
                next: data.response_metadata && data.response_metadata.next_cursor,
            }));
        }
        // cursorOrOptions is options object
        return this.callMethod('users.list', cursorOrOptions).then(data => ({
            members: data.members,
            next: data.response_metadata && data.response_metadata.next_cursor,
        }));
    }
    getAllUserList(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let allUsers = [];
            let continuationCursor;
            do {
                const { members: users, next, } = yield this.getUserList(Object.assign({ cursor: continuationCursor }, options));
                allUsers = allUsers.concat(users);
                continuationCursor = next;
            } while (continuationCursor);
            return allUsers;
        });
    }
}
exports.default = SlackOAuthClient;
//# sourceMappingURL=SlackOAuthClient.js.map